# Техническое задание: Торговое ядро

## 1. Цель

Создать высокопроизводительное торговое ядро для автоматического арбитража фьючерсов между 6 криптовалютными биржами.

**Ключевые характеристики:**
- Латентность: Tick → Order < 5ms (без учёта сети)
- Мониторинг: до 30 пар на 6 биржах одновременно (180 потоков цен)
- Параллелизм: независимая обработка каждой пары
- Надёжность: работа 24/7 с автоматическим восстановлением после сбоев

---

## 2. Функциональные требования

### 2.1. Мониторинг цен

**Источник данных:** WebSocket от бирж (не REST polling)

**Что получаем:**
- Best bid/ask (лучшая цена покупки/продажи)
- Orderbook 10 уровней глубины
- Обновления в реальном времени (каждые 100-500ms)

**Поддерживаемые биржи:**
1. Bybit
2. Bitget
3. BingX
4. Gate.io
5. OKX
6. HTX
7. MEXC

**Требования:**
- Одно WebSocket соединение на биржу
- Подписка на все активные символы
- Автоматический reconnect при обрыве (экспоненциальный backoff)
- Парсинг и валидация входящих данных

---

### 2.2. Расчёт спреда

**Формула чистого спреда:**

```
1. Средняя цена покупки (на дешёвой бирже):
   P_buy_avg = взвешенная средняя по 10 уровням asks для объёма V

2. Средняя цена продажи (на дорогой бирже):
   P_sell_avg = взвешенная средняя по 10 уровням bids для объёма V

3. Грубый спред:
   Spread (%) = ((P_sell_avg - P_buy_avg) / P_buy_avg) × 100

4. Комиссии на вход и выход:
   Total_fees = 2 × (fee_exchange_A + fee_exchange_B)

5. Чистый спред:
   Net_spread = Spread (%) - Total_fees
```

**Проверка перед входом:**
- Net_spread >= порог входа (из параметров пары)

**Проверка перед выходом:**
- Net_spread <= порог выхода (из параметров пары)

---

### 2.3. Управление позициями

#### Состояния пары

```
PAUSED         → пара на паузе (пользователь остановил)
READY          → мониторинг активен, ждём условий входа
ENTERING       → процесс входа (выставление ордеров)
POSITION_OPEN  → позиции открыты, сопровождение
EXITING        → процесс выхода (закрытие позиций)
ERROR          → ошибка, требуется вмешательство
```

#### Параметры пары (задаёт пользователь)

```go
type PairConfig struct {
    Symbol         string  // "BTCUSDT"
    Volume         float64 // 0.5 BTC
    EntrySpread    float64 // 1.0%
    ExitSpread     float64 // 0.3%
    NumOrders      int     // 4 (разбить объём на 4 части)
    StopLoss       float64 // 100 USDT (опционально)
    Leverage       int     // 10x
}
```

---

### 2.4. Вход в позицию (арбитраж)

#### Алгоритм входа

**Шаг 1: Проверка условий**
- Спред >= порога входа ✓
- Баланс на обеих биржах достаточен ✓
- Нет превышения лимита одновременных арбитражей ✓

**Шаг 2: Установка плеча (если первый раз для пары)**
- REST запрос на каждую биржу: установить плечо
- Кэшировать в БД: плечо установлено
- После установки: **проверить спред ещё раз**

**Шаг 3: Вход частями (если NumOrders > 1)**

```
Для i от 1 до NumOrders:
    1. Проверить текущий спред
    2. Если спред >= порога входа:
       - Рассчитать объём части: V_part = Volume / NumOrders
       - Параллельно выставить 2 рыночных ордера:
         * Long на дешёвой бирже (buy)
         * Short на дорогой бирже (sell)
       - Дождаться исполнения обоих
    3. Иначе (спред < порога входа):
       - Если спред <= порога выхода:
         * Начать выход (закрыть уже открытое)
       - Иначе:
         * Ждать (позиция частично открыта)
    4. Продолжить для следующей части
```

**Обработка ошибок:**

**Если один ордер исполнился, второй нет:**
```
1. Пока спред >= порога входа:
   - Повторить попытку открыть вторую ногу (до 3 попыток)
   - Интервал: 0.5s, 1s, 2s (exponential backoff)

2. Если не удалось:
   - Закрыть первую ногу рыночным ордером
   - Пару на ПАУЗУ
   - Уведомление: "Не удалось открыть вторую ногу"
```

**Если биржа отклонила ордер (insufficient margin, rate limit):**
```
1. Для "Rate limit exceeded":
   - Подождать 1 секунду
   - 1 повторная попытка
   - Если не вышло → закрыть первую ногу, пауза

2. Для "Insufficient margin":
   - Сразу закрыть первую ногу, пауза

3. Для сетевых ошибок:
   - 2 попытки с задержкой 500ms
   - Если не вышло → закрыть первую ногу, пауза
```

---

### 2.5. Сопровождение позиции

#### Мониторинг во время удержания

**Каждую секунду:**
1. Получить текущие цены с обеих бирж
2. Рассчитать нереализованный PNL:
   ```
   PNL_long  = (P_current_long - P_open_long) × Volume
   PNL_short = (P_open_short - P_current_short) × Volume
   Total_PNL = PNL_long + PNL_short
   ```
3. Проверить условия выхода

#### Условия выхода

**A) Целевой профит (спред выхода):**
```
Если текущий Net_spread <= порог выхода:
    → Начать выход частями
```

**B) Stop Loss:**
```
Если SL задан И Total_PNL <= -SL:
    → Немедленно закрыть обе позиции (market orders)
    → Пару на ПАУЗУ
    → Уведомление: "Stop Loss сработал"
```

**C) Ликвидация:**
```
Если биржа ликвидировала одну позицию:
    → Немедленно закрыть вторую позицию
    → Пару на ПАУЗУ
    → Уведомление: "Ликвидация произошла"
```

---

### 2.6. Выход из позиции

#### Алгоритм выхода (зеркальный входу)

```
Для i от 1 до NumOrders:
    1. Проверить текущий спред
    2. Если спред <= порога выхода:
       - Рассчитать объём части для закрытия
       - Параллельно выставить 2 рыночных ордера:
         * Закрыть long (sell)
         * Закрыть short (buy)
       - Дождаться исполнения
    3. Иначе (спред расширился обратно):
       - Если спред >= порога входа:
         * Можем добрать позицию (если были частично)
       - Иначе:
         * Ждать
```

**После полного выхода:**
1. Рассчитать реализованный PNL
2. Обновить статистику пары (N сделок +1, Total PNL)
3. Перевести пару в статус READY (ждём новый вход)

---

### 2.7. Плавающее состояние (частичный вход/выход)

**Ситуация:** Вошли 2 из 4 частей, спред схлопнулся до уровня выхода.

**Действия:**
```
1. Начинаем выход частями (закрываем 2 части)
2. Во время выхода:
   - Если спред опять расширился >= порога входа:
     * Можем добрать оставшиеся 2 части
   - Если спред остался <= порога выхода:
     * Продолжаем выход
```

**Цель:** Максимизировать прибыль, используя колебания спреда.

---

### 2.8. WebSocket Reconnect

**При обрыве WebSocket соединения:**

```
1. Логировать событие: "WebSocket disconnected: {биржа}"

2. Попытки переподключения:
   - Попытка 1: через 2 секунды
   - Попытка 2: через 4 секунды
   - Попытка 3: через 8 секунд
   - Попытка 4: через 16 секунд
   - Попытка 5: через 32 секунды

3. Если все попытки неудачны:
   - Все пары с этой биржей → ПАУЗА
   - Уведомление: "Потеряно соединение с {биржа}"

4. При успешном переподключении:
   - Переподписка на все символы
   - Восстановление мониторинга
```

**Если reconnect во время открытой позиции:**
```
1. Приостановить вход/выход до восстановления соединения
2. Держать позицию открытой
3. После reconnect:
   - Проверить актуальные цены
   - Проверить условия (спред входа/выхода)
   - Продолжить логику сопровождения
```

---

### 2.9. Restart после перезапуска сервера

**При старте бота:**

```
1. Загрузить конфигурацию пар из БД

2. Через REST API каждой биржи:
   - Получить список открытых позиций

3. Если найдены открытые позиции:
   - Закрыть все позиции рыночными ордерами
   - Все пары → ПАУЗА
   - Уведомление: "При перезапуске закрыты позиции"

4. Начать мониторинг для пар в статусе READY
```

---

## 3. Архитектурные требования

### 3.1. Язык и технологии

- **Язык:** Go 1.21+
- **WebSocket:** gorilla/websocket или nhooyr/websocket
- **JSON парсинг:** jsoniter (быстрее стандартного)
- **База данных:** PostgreSQL (для конфигурации, истории)
- **Метрики:** Prometheus client

### 3.2. Структура модулей

```
internal/
├── core/
│   ├── engine/          # Основной движок (coordinator)
│   ├── arbitrage/       # Логика арбитража для одной пары
│   ├── prices/          # Агрегация цен с бирж
│   └── orderbook/       # Работа со стаканами
│
├── exchanges/
│   ├── bybit/          # Коннектор Bybit
│   ├── bitget/         # Коннектор Bitget
│   ├── bingx/          # Коннектор BingX
│   ├── gate/           # Коннектор Gate.io
│   ├── okx/            # Коннектор OKX
│   ├── htx/            # Коннектор HTX
│   ├── mexc/           # Коннектор MEXC
│   └── common.go       # Общий интерфейс
│
├── state/
│   ├── machine.go      # State machine для пары
│   └── transitions.go  # Переходы между состояниями
│
├── risk/
│   ├── balance.go      # Проверка баланса
│   ├── stoploss.go     # Логика Stop Loss
│   └── limits.go       # Лимиты (мин. объёмы, leverage)
│
└── db/
    ├── models.go       # Структуры данных
    └── repository.go   # CRUD операции
```

### 3.3. Параллелизм и производительность

**Шардирование по символам:**
```
Num_shards = runtime.NumCPU() (мин 4, макс 32)

Для каждого символа:
    shard_id = hash(symbol) % Num_shards

Worker на каждый шард обрабатывает события для своих символов
```

**Каналы для событий:**
```go
type PriceUpdate struct {
    Exchange  string
    Symbol    string
    BestBid   float64
    BestAsk   float64
    Orderbook []Level
    Timestamp time.Time
}

// Буфер канала: 2000 на шард
priceChannel := make(chan PriceUpdate, 2000)
```

**Object pooling:**
```go
var priceUpdatePool = sync.Pool{
    New: func() interface{} {
        return &PriceUpdate{}
    },
}

// Переиспользование объектов
update := priceUpdatePool.Get().(*PriceUpdate)
defer priceUpdatePool.Put(update)
```

---

## 4. Интеграция с другими модулями

### 4.1. REST API (для фронтенда)

Торговое ядро предоставляет следующие методы:

```
POST /api/pairs            # Добавить пару
GET  /api/pairs            # Список пар
PATCH /api/pairs/:id       # Изменить параметры
DELETE /api/pairs/:id      # Удалить пару

POST /api/pairs/:id/start  # Запустить мониторинг
POST /api/pairs/:id/pause  # Поставить на паузу
```

### 4.2. WebSocket (для фронтенда)

Торговое ядро отправляет события:

```json
{
  "type": "pairUpdate",
  "id": 1,
  "symbol": "BTCUSDT",
  "status": "POSITION_OPEN",
  "currentSpread": 0.85,
  "pnl": 12.5,
  "exchanges": ["bybit", "bitget"]
}
```

### 4.3. База данных

**Таблицы:**

```sql
-- Конфигурация пар
CREATE TABLE pairs (
    id SERIAL PRIMARY KEY,
    symbol VARCHAR(20) NOT NULL,
    volume DECIMAL(18,8) NOT NULL,
    entry_spread DECIMAL(5,2) NOT NULL,
    exit_spread DECIMAL(5,2) NOT NULL,
    num_orders INT NOT NULL,
    stop_loss DECIMAL(18,2),
    leverage INT NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- История сделок
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    pair_id INT REFERENCES pairs(id),
    entry_time TIMESTAMP NOT NULL,
    exit_time TIMESTAMP,
    entry_spread DECIMAL(5,2),
    exit_spread DECIMAL(5,2),
    realized_pnl DECIMAL(18,2),
    exchange_long VARCHAR(20),
    exchange_short VARCHAR(20),
    volume DECIMAL(18,8),
    closed_by VARCHAR(20) -- 'target', 'sl', 'liquidation', 'manual'
);

-- Кэш плеча
CREATE TABLE leverage_cache (
    exchange VARCHAR(20),
    symbol VARCHAR(20),
    leverage INT,
    updated_at TIMESTAMP,
    PRIMARY KEY (exchange, symbol)
);
```

---

## 5. Нефункциональные требования

### 5.1. Производительность

- Tick → Order: < 5ms (внутренняя обработка)
- Расчёт спреда: < 0.5ms
- Парсинг JSON: < 0.1ms

### 5.2. Надёжность

- Работа 24/7 без перезапуска
- Автоматическое восстановление при сбоях WebSocket
- Graceful shutdown (корректное закрытие позиций)

### 5.3. Безопасность

- API ключи бирж хранятся в зашифрованном виде
- Rate limiting для предотвращения блокировки
- Валидация всех входных данных

### 5.4. Мониторинг

- Метрики Prometheus
- Структурированное логирование (JSON)
- Алерты при превышении пороговых значений

---

## 6. Ограничения первой версии

**Что НЕ входит в торговое ядро:**

- Веб-интерфейс (делает напарник)
- Аутентификация пользователей
- Управление API ключами бирж (отдельный модуль)
- Расширенная аналитика и отчёты
- Бэктестинг на исторических данных

**Упрощения:**

- Рыночные ордера всегда исполняются полностью (не обрабатываем partial fill в первой версии)
- Один пользователь (не multi-tenancy)
- Плечо устанавливается один раз для пары (не меняется динамически)

---

## 7. Критерии приёмки

Торговое ядро считается готовым, если:

✅ Успешно открывает и закрывает арбитраж на 2 биржах (1 полный цикл)
✅ Корректно работает вход/выход частями (N=4)
✅ Stop Loss срабатывает корректно
✅ Reconnect восстанавливает мониторинг после обрыва WebSocket
✅ Латентность Tick → Order < 10ms (измерено на продакшене)
✅ Обрабатывает 30 пар на 6 биржах без потери событий
✅ Работает 24 часа без сбоев на VPS

---
